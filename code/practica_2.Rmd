---
title: "Tipologia i cicle de vida de les dades - Pràctica 2"
author: "Autor: Isabel Barrera Benavent i Maria Font Sánchez"
date: "Decembre 2021"
output:
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T, fig.width=12, fig.height=8)
```
*****
# Descripció del dataset. Perquè és important i quina pregunta/problema pretén respondre?
*****
El dataset que hem decidit fer servir per aquesta pràctica és el següent: 

https://www.kaggle.com/imakash3011/customer-personality-analysis

És un conjunt de dades obtingut de la web Kaggle i construit per 29 atributs, dels quals hi ha un d’ells que és l’identificador únic del registre, 25 atributs numèrics enters i 3 atributs de tipus text.

Es tracta d’una enquesta feta a 2.240 clients d’una empresa per a poder valorar la seva personalitat a l’hora de comprar els seus productes i amb la finalitat de comprendre i analitzar els gustos i necessitats que tenen segons el tipus de clients que siguin. 

D’aquesta manera l’empresa pot prendre decisions respecte als productes que ven o fer campanyes de marketing més específiques segons el tipus de clients i producte.


Els atributs que conté el dataset són els següents: 

- ID:   Identificador únic del client.
- Year_Birth: Any de naixement del client.
- Education: Nivell d’educació del client.
- Marital_Status: Estat marital del client. 
- Income: Ingrés familiar del client.
- Kidhome: Número de fills amb qui viu el client.	
- Teenhome: Número d’adolescents amb qui viu el client.		
- Dt_Customer: Data en que el client s’inscriu com client de l’empresa.	
- Recency: Número de dies que han passat desde  l’última compra del client.
- MntWines: Quantitat gastada en vi durant els últims dos anys per el client.
- MntFruits:Quantitat gastada en vi durant els últims dos anys per el client.	
- MntMeatProducts:Quantitat gastada en carn durant els últims dos anys per el client.
- MntFishProducts: Quantitat gastada en peix durant els últims dos anys per el client.
- MntSweetProducts: Quantitat gastada en dolços durant els últims dos anys per el client.
- MntGoldProds: Quantitat gastada en or durant els últims dos anys per el client.
- NumDealsPurchases: Número de compres realitzades amb descomptes per el client. 
- NumWebPurchases: Número de compres realitzades des de la web de l’empresa per el  client.
- NumCatalogPurchases: Número de compres realitzades des del catàleg de l’empresa per el client.
- NumStorePurchases: Número de compres realitzades directament en una tenda de l’empresa per el client.
- NumWebVisitsMonth: Número de  visites realitzades durant l’últim mes a la web de l’empresa del client.
- AcceptedCmp3: 1 si el client va acceptar l’oferta en la tercera campanya, 0 en cas contrari
- AcceptedCmp4: 1 si el client va acceptar l’oferta en la quarta campanya, 0 en cas contrari.
- AcceptedCmp5: 1 si el client va acceptar l’oferta en la cinquena campanya, 0 en cas contrari.
- AcceptedCmp1: 1 si el client va acceptar l’oferta en la primera campanya, 0 en cas contrari.
- AcceptedCmp2: 1 si el client va acceptar l’oferta en la segons campanya, 0 en cas contrari.
- Complain: 1 si hi ha hagut alguna queixa del client en els últims dos anys. 0 en cas contrari.
- Z_CostContact: Cost Contacte. Té valor 3 per defecte.
- Z_Revenue: Ingresos del client: Té valor 11 per defecte.	
- Response: 1 si el client va acceptar l’oferta en la última campanya, 0 en cas contrari.

A partir del conjunt de dades d’aquest dataset, es preten estudiar com influleix el perfil del client amb la quantitat gastada en les compres de productes d’aliments. Per això, s’aplicaran mètodes de regressió per a veure la relació entre les diferents variables, i mètodes de classificació per a crear el perfil del client.
Aquest estudi és important per a les empreses de ventes de productes (tan online com físiques) per a poder identificar el tipus de client que compra cada producte i crear aíxi campanyes de màrketing específiques.

*****
# Integració i selecció de les dades d'interès a analitzar
*****

Per tal de poder realitzar la selecció de les dades d'interès a analitzar, el primer pas és fer la lectura del fitxer CSV anomenat 'marketing_campaign.csv':

```{r message= FALSE, warning=FALSE}
data_clients<-read.csv("../data/marketing_campaign.csv", header=T, sep="\t")
```

D'aquestes 29 variables, ens interessa quedar-nos amb les següents:

- ID: identificador únic

  Perfil del client:
- Year_Birth
- Education
- Marital_status
- Income
- Kidhome
- Teenhome
- Dt_Customer

  Gasto per productes alimentaris:
- MntFruits
- MntMeatProducts
- MntFishProducts
- MntSweetProducts
- NumWebPurchases
- NumCatalogPurchases
- NumStorePurchases

La resta de variables, degut a que no es faran servir, s'eliminen del conjunt de dades:

```{r message= FALSE, warning=FALSE}
data_clients <- data_clients[, c('ID', 'Year_Birth', 'Education', 'Marital_Status', 'Income', 'Kidhome', 'Teenhome', 
                                 'Dt_Customer', 'MntFruits', 'MntMeatProducts', 'MntFishProducts', 'MntSweetProducts',
                                 'NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases')]

```

*****
# Neteja de dades
*****

Abans de començar amb la neteja de dades, cal mirar el tipus de dades que R ha assignat a cada columna, i també amb la funció 'summary' es pot veure els valors màxims, mínims i les mitjanes de les variables numèriques.

```{r message= FALSE, warning=FALSE}
summary(data_clients)
```

Es pot observar que les variables 'Education', 'Marital Status' i 'Dt Customer' són les úniques expressades com a text. La resta de variables són numèriques.

Primer, es validarà que les variables de text 'Education' i 'Marital Status' es poden categoritzar:

```{r message= FALSE, warning=FALSE}
table(data_clients$Education)
table(data_clients$Marital_Status)
```

Totes dues variables es poden categoritzar:

```{r message= FALSE, warning=FALSE}
data_clients$Education <- as.factor(data_clients$Education)
data_clients$Marital_Status <- as.factor(data_clients$Marital_Status)
```


*****
## Zeros o elements buits
*****

### Les dades contenen zeros o elements buits? Com gestionaries aquests casos?

Les variables numèriques utilitzen el valor 0 per indicar que no es té informació. I les de tipus text ho indiquen mitjançant els elements buits.
El primer pas per a fer aquesta comprobació, es validar si existeixen valors buits en les variables seleccionades:

```{r message= FALSE, warning=FALSE}
colSums(is.na(data_clients))
```

En aquest cas, la variable 'Income' en té 24. Per tal de gestionar aquests valors, hi ha diverses tècniques que es poden aplicar:
- Eliminar aquests registres.
- Aplicar la mitjana dels valors més propers.

Degut a que es tracta d'1% dels registres totals, es preferible eliminar-los ja que l'impacte i la pèrduda de dades és mínima:

```{r message= FALSE, warning=FALSE}
data_clients <- na.omit(data_clients)
colSums(is.na(data_keep))
```


### Identificació i tractament de valors extrems

El següent pas és identificar els valors extrems, que són les dades que es troben allunyades de la distribució normal.

Utilitzarem la funció boxplots.stats() de R per anar revisant variable a variable si trobem registres amb valors extrems 
que es puguin considerar incorrectes o que ens pugui implicar una desviació important. 

VARIABLE YEAR_BIRTH

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$Year_Birth)$out
summary(data_clients$Year_Birth)

## En aquest cas considerem que aquests 3 valors són incorrectes, ja que implicaria que actualment tenen més de 130 anys.
## Decidim canviar-los per el valor mitjà.
median_year_birth <- data_clients$Year_Birth

data_clients$Year_Birth[(data_clients$Year_Birth==1893)] <- median_year_birth
data_clients$Year_Birth[(data_clients$Year_Birth==1900)] <- median_year_birth
data_clients$Year_Birth[(data_clients$Year_Birth==1899)] <- median_year_birth
```

VARIABLES EDUCATION, MARITAL STATUS, KIDHOME, TEENHOME I NUMSTORESPURCHASES:  

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$Education)$out
boxplot.stats(data_clients$Marital_Status)$out
boxplot.stats(data_clients$Kidhome)$out
boxplot.stats(data_clients$Teenhome)$out
boxplot.stats(data_clients$NumStorePurchases)$out

table(data_clients$Education)
table(data_clients$Marital_Status)
table(data_clients$Kidhome)
table(data_clients$Teenhome)
table(data_clients$NumStorePurchases)

## No sembla que hi hagin valors extrems. 
## Revisem els seus valor amb la funció table
```

VARIABLE DT_CUSTOMER:  
```{r message= FALSE, warning=FALSE}
# Revisem els anys de les dates de clients per si veiem alguna cosa rara.

boxplot(as.numeric(substring(data_clients$Dt_Customer,7,10)))
table(as.numeric(substring(data_clients$Dt_Customer,7,10)))

## Tant la seva representació en boxplot com en taula és correcta.
```
VARIABLE NUMWEBPURCHASES: 

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$NumWebPurchases)$out
summary(data_clients$NumWebPurchases)

## Els valors extrems són valors que es poden donar. Els donem per bons.
```

VARIBALE NUMCATALOGPURCHAES:
```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$NumCatalogPurchases)$out
summary(data_clients$NumCatalogPurchases)

## Els valors extrems són valors que es poden donar. Els donem per bons.
```
VARIABLE MNTFRUITS:
```{r message= FALSE, warning=FALSE}
## Al tenir tants valors diferents, representem el seu boxplot:

boxplot(data_clients$MntFruits)
summary(data_clients$MntFruits)

## Veiem que hi han valors que estàn fora de ho esperat pero no allunyats entre ells i a més es poden donar.
## Ho donem per bo.
```
VARIABLE MNTFISHPRODUCTS:
```{r message= FALSE, warning=FALSE}
 
## Al tenir tants valors diferents, representem el seu boxplot
boxplot(data_clients$MntFishProducts)
summary(data_clients$MntFishProducts)
## Veiem que hi han valors que estàn fora de ho esperat pero no allunyats entre ells i a més es poden donar.
## Ho donem per bo.
```
VARIABLE MNTSWEETPRODUCTS:
```{r message= FALSE, warning=FALSE}
boxplot(data_clients$MntSweetProducts)
summary(data_clients$MntSweetProducts)

## Veiem que hi han un valor que estàn molt fora de ho esperat.
## Al ser només un el canviem per la mitjana.

data_clients$MntSweetProducts[(data_clients$MntSweetProducts==262)] <- median(data_clients$MntSweetProducts)
```
VARIABLE MNTMEATPRODUCTS;
```{r message= FALSE, warning=FALSE}
## Camp MntMeatProducts:  
## Al tenir tants valors diferents, representem el seu boxplot
boxplot(data_clients$MntMeatProducts)
summary(data_clients$MntMeatProducts)
## Sembla que hi han uns 4 valors superiors dels 1500 i diferenciats dels altres.
table(data_clients$MntMeatProducts[(data_clients$MntMeatProducts>1500)] )
## Els canviem per la seva mitjana:
data_clients$MntMeatProducts[(data_clients$MntMeatProducts>1500)] <- median(data_clients$MntMeatProducts)
```

VARIABLE INCOME:
```{r message= FALSE, warning=FALSE}
## Camp Income:  
## Al tenir tants valors diferents, representem el seu boxplot
boxplot(data_clients$Income)
summary(data_clients$Income)
## Hi ha un valor molt superior al altres.
table(data_clients$Income[(data_clients$Income>300000)] )
## Els canviem per la seva mitjana:
data_clients$Income[(data_clients$Income>300000)] <- median(data_clients$Income)
```

*****
## Anàlisi de les dades
*****

### Selecció dels grups de dades que es volen analitzar/comparar (planificació dels anàlisis a aplicar)

La selecció dels grups de dades ha de permetre realitzar les proves estadístiques en funció dels grups a comparar o analitzar.

Per això, es seleccionaran les dades en funció de les variables 'Education' i 'Marital Status', aquestes són les que s'han categoritzat anteriorment.

```{r message= FALSE, warning=FALSE}
#Agrupació per estudis:

data_clients.basic <- data_clients[data_clients$Education == "Basic",]
data_clients.graduation <- data_clients[data_clients$Education == "Graduation",]
data_clients.cycle <- data_clients[data_clients$Education == "2n Cycle",]
data_clients.master <- data_clients[data_clients$Education == "Master",]
data_clients.phd <- data_clients[data_clients$Education == "PhD",]

#Agrupació per estat civil:
data_clients.divorced <- data_clients[data_clients$Education == "Divorced",]
data_clients.married <- data_clients[data_clients$Education == "Married",]
data_clients.single <- data_clients[data_clients$Education == "Single" || data_clients$Education == "Alone",]
data_clients.together <- data_clients[data_clients$Education == "Together",]
data_clients.widow <- data_clients[data_clients$Education == "Widow",]

```


### Comprovació de la normalitat i homogeneïtat de la variància

Per a poder realitzar les proves estadístiques, cal comprovar la normalitat i la homogeneïtat de la variància.

En aquest cas utilitzarem el test de Shaprio-Wilk, on diu que si el p-valor és més petit que α=0,05, es conclou que les dades no estan seguint una distribució normal. Per contra, si p-valor es major que α=0,05, les dades sí que estan seguint una distribució normal.

Les variables que es mesurarà la normalitat són les del tipus numèric, i que no siguin la variable ID (corresponen a l'identificador), i Kidhome i Teenhome ja que corresponen a valors booleans del tipus 0 i 1.

```{r message= FALSE, warning=FALSE}
options(scipen = 100)
par(mfrow=c(2,2))

p_value <- 0.05

columnes <- colnames(data_clients)

colnames_not_check <- c("ID", "Kidhome", "Teenhome")

for (i in 1:ncol(data_clients)) {
  col <- data_clients[,i]
  if(is.numeric(col) && !is.element(colnames(data_clients)[i], colnames_not_check)){
    qqnorm(col, main = paste("Normal Q-Q plot: ", colnames(data_clients)[i]));
    qqline(col, col = 2)
    
    normality_pvalue <- shapiro.test(col)$p.value
    
    if(normality_pvalue < p_value){
      cat("Distribució NO normalitzada de la columna: ", colnames(data_clients)[i])
    }else{
      cat("Distribució normal de la columna: ", colnames(data_clients)[i])
    }
    cat("\n")
  }
}

```

Es pot observar en el diagrama Q-Q i fent el test Shapiro-Wilk, que cap de les variables està normalitzada.

Es proposa normalitzar les variables següents, ja que la resta, es bo que es vegin els valors reals: MntFruits, MntMeatProducts, MntFishProducts, MntSweetProducts, NumWebPurchases, NumCatalogPurchases, NumStorePurchases. 
En aquest cas s'aplica la transformació Box-Cox:

```{r message= FALSE, warning=FALSE}
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')
if (!require('forecast')) install.packages('forecast'); library('forecast')

par(mfrow=c(2,2))

data_clients_normalitzat <- data_clients
data_prep <- data_clients[,c('MntFruits', 'MntMeatProducts', 'MntFishProducts', 'MntSweetProducts', 'NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases')]
data_clients_normalitzat$MntFruits <- BoxCox(data_clients[,c('MntFruits')], 1/2)
data_clients_normalitzat$MntMeatProducts <- BoxCox(data_clients[,c('MntMeatProducts')], 1/2)
data_clients_normalitzat$MntFishProducts <- BoxCox(data_clients[,c('MntFishProducts')], 1/2)
data_clients_normalitzat$MntSweetProducts <- BoxCox(data_clients[,c('MntSweetProducts')], 1/2)
data_clients_normalitzat$NumWebPurchases <- BoxCox(data_clients[,c('NumWebPurchases')], 1/2)
data_clients_normalitzat$NumCatalogPurchases <- BoxCox(data_clients[,c('NumCatalogPurchases')], 1/2)
data_clients_normalitzat$NumStorePurchases <- BoxCox(data_clients[,c('NumStorePurchases')], 1/2)

ggplot(data_clients_normalitzat, aes(x = MntFruits)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntFruits")

ggplot(data_clients_normalitzat, aes(x = MntMeatProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntMeatProducts")

ggplot(data_clients_normalitzat, aes(x = MntFishProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntFishProducts")

ggplot(data_clients_normalitzat, aes(x = MntSweetProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntSweetProducts")

ggplot(data_clients_normalitzat, aes(x = NumWebPurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumWebPurchases")

ggplot(data_clients_normalitzat, aes(x = NumCatalogPurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumCatalogPurchases")

ggplot(data_clients_normalitzat, aes(x = NumStorePurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumStorePurchases")

```

Un cop es tenen les dades normalitzades, es fa l'estudi de l'homoscedasticitat. S'utilitzarà el test de Fligner-Killeen ja que es volen comparar les dades normalitzades amb les que no ho han estat.

Tal i com passava amb el test Shapiro-Wilk, si el p-value és inferior a 0.05, es conclou que les dades no són homogènies:

```{r message= FALSE, warning=FALSE}

fligner.test(Year_Birth ~ MntFruits, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntMeatProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntFishProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntSweetProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumWebPurchases, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumCatalogPurchases, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumStorePurchases, data = data_clients_normalitzat)

```

Les variables següents són homogènies ja que el p-value és superior a 0.05: Year_Birth by MntFishProducts, Year_Birth by NumWebPurchases.
La resta no ho són.


### Aplicació de proves estadístiques per comparar els grups de dades


### Aplicació de proves estadístiques per comparar els grups de dades. 
#### En funció de les dades i de l'objectiu de l'estudi, aplicar proves de contrast 
## d'hipòtesis, correlacions, regressions etc.

ANÀLISIS DE CORRELACIÓ:

Procedim a realitzar un anàlisis de correlació amb les diferents variables i així verificar si hi ha alguna amb que tingui una dependència prou gran per creure que té una influència.

Utilitzarem les dades normalitzades (data_clients_normalitzat):

```{r message= FALSE, warning=FALSE}

corr_matrix <- matrix(nc = 2, nr = 0)
colnames(corr_matrix) <- c("estimate", "p-value")
# Calcular el coeficiente de correlación para cada variable cuantitativa
# con respecto al campo "precio"
for (i in 1:(ncol(data_clients_normalitzat) - 1)) {
  if (is.integer(data_clients_normalitzat[,i]) | is.numeric(data_clients_normalitzat[,i])) {
    spearman_test = cor.test(data_clients_normalitzat[,i],
    data_clients_normalitzat[,9],
    method = "spearman")
    corr_coef = spearman_test$estimate
    p_val = spearman_test$p.value
    # Add row to matrix
    pair = matrix(ncol = 2, nrow = 1)
    pair[1][1] = corr_coef
    pair[2][1] = p_val
    corr_matrix <- rbind(corr_matrix, pair)
    rownames(corr_matrix)[nrow(corr_matrix)] <- colnames(data_clients_normalitzat)[i]
  }
}
print(corr_matrix)

```

Les variables amb més correlació amb la quantitat de número de Fruita comprada són els que estàn més a prop dels valors -1 i 1. 

En aquest cas són MntMeatProducts i MntSweetProducts amb la que tenen una correlació més alta, però en cap cas és rellevant.

ANÀLISIS DE CONTRAST:

Mirem ara de fer prova de contrast d'hipòtesi:

Com que quasi totes les relaciones entre les variables no són homogènees utilitzarem el tets de kruskal entre els diferentes variables i mntsweetproducts, revisant quin valor de p-value dona.

Si és menor a 0,05 concluirem que el els diners que es gasta en productes dolços és variant segons els diferents valors de l'altra variable.



```{r message= FALSE, warning=FALSE}


cont_matrix <- matrix(nc = 2, nr = 0)
colnames(cont_matrix) <- c("statistic", "p-value")
# Calcular el coeficiente de correlación para cada variable cuantitativa
# con respecto al campo "precio"
for (i in 1:(ncol(data_clients) - 1)) {
  if (is.integer(data_clients[,i]) | is.numeric(data_clients[,i])) {
    kruskal_test = kruskal.test(MntSweetProducts ~ data_clients[,i] , data = data_clients)
    statistic = kruskal_test$statistic
    p_val = kruskal_test$p.value
    # Add row to matrix
    pair = matrix(ncol = 2, nrow = 1)
    pair[1][1] = statistic
    pair[2][1] = p_val
    cont_matrix <- rbind(cont_matrix, pair)
    rownames(cont_matrix)[nrow(cont_matrix)] <- colnames(data_clients)[i]
  }
}
print(cont_matrix)


```

En aquest cas, revisem que tots els valors són inferiors a 0,05, per tant tenen rellevància amb la variable.

Fem també una prova de t-test per les dades preparades anteriorment. Per molt que no siguin normals, al tenir un tamany prou gran podem utilitzar la prova. 

Revisem el test entre els diferents grups d'estudis i estat civil per veure si hi ha alguna relació:


```{r message= FALSE, warning=FALSE}

print(paste("t-students basic vs graduation:",t.test(data_clients.basic$MntFruits, data_clients.graduation$MntFruits,alternative = "less")$p.value))
print(paste("t-students basic vs cycle:",t.test(data_clients.basic$MntFruits, data_clients.cycle$MntFruits,alternative = "less")$p.value))
print(paste("t-students basic vs master:",t.test(data_clients.basic$MntFruits, data_clients.master$MntFruits,alternative = "less")$p.value))
print(paste("t-students basic vs master:",t.test(data_clients.basic$MntFruits, data_clients.phd$MntFruits,alternative = "less")$p.value))
print(paste("t-students graduation vs cycle:",t.test(data_clients.graduation$MntFruits, data_clients.cycle$MntFruits,alternative = "less")$p.value))
print(paste("t-students graduation vs master:",t.test(data_clients.graduation$MntFruits, data_clients.master$MntFruits,alternative = "less")$p.value))
print(paste("t-students phd vs alternative:",t.test(data_clients.graduation$MntFruits, data_clients.phd$MntFruits,alternative = "less")$p.value))
print(paste("t-students cycle vs alternative:",t.test(data_clients.cycle$MntFruits, data_clients.master$MntFruits,alternative = "less")$p.value))
print(paste("t-students cycle vs phd:",t.test(data_clients.cycle$MntFruits, data_clients.phd$MntFruits,alternative = "less")$p.value))
print(paste("t-students master vs alternativa:",t.test(data_clients.master$MntFruits, data_clients.phd$MntFruits,alternative = "less")$p.value))



```
D'aquí podem concloure que com més alts són els estudis més semblants són les seves compres respecte a la fruita.
No es pot fer la mateixa proba per els estats civils ja que la majoria de clients estan casats, divorciats o junts:

```{r message= FALSE, warning=FALSE}
summary(data_clients$Marital_Status)
```

## Representació dels resultats a partir de taules gràfiques

Les taules gràfiques han d'ajudar a representat els resultats mostrats anteriorment.

Primerament, es comprova que les compmres realitzades a la fruita i la carna en relació als estudis que tenen (s'ha comprovat en les proves estadístiques que els estudis i les compres de fruita tenen relació, s'ha afegit en aquest gràfic les compres de carn per a poder contrastar el diferents productes):

```{r message= FALSE, warning=FALSE}
if (!require('ggplot2')) install.packages('ggplot2'); library(ggplot2)

ggplot(data_clients_normalitzat, aes(x=MntFruits, y=MntMeatProducts, color=Education)) + 
    geom_point(size=6) 
```

Es pot observar que hi ha una gran diferència de les persones amb estudis bàsics, que gasten menys diners en la compra de fruita i de carn. Tot i així, les persones amb la resta d'estudis, compren per sobre de la mitjana.


Degut a que l'educació no és un factor rellevant, es decideix fer ús de l'edat amb les variables en referència a la compra de fruita, carn, peix i dolços:

```{r message= FALSE, warning=FALSE}
if (!require('gridExtra')) install.packages('gridExtra'); library('gridExtra')

plotMeat <- ggplot(data_clients_normalitzat, aes(x=Year_Birth, y=MntMeatProducts) ) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white")

plotFruits <- ggplot(data_clients_normalitzat, aes(x=Year_Birth, y=MntFruits) ) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white")

plotFish <- ggplot(data_clients_normalitzat, aes(x=Year_Birth, y=MntFishProducts) ) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white")

plotSweet <- ggplot(data_clients_normalitzat, aes(x=Year_Birth, y=MntSweetProducts) ) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white")

grid.arrange(plotMeat, plotFruits, plotFish, plotSweet)

```

En aquest cas s'observa que l'edat (any de naixement) és una bona variable que influeix en la compra de productes.

