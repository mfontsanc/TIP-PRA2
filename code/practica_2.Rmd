---
title: "Tipologia i cicle de vida de les dades - Pràctica 2"
author: "Autor: Isabel Barrera Benavent i Maria Font Sánchez"
date: "Decembre 2021"
output:
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T, fig.width=12, fig.height=8)
```


*****
# Integració i selecció de les dades d'interès a analitzar
*****

Per tal de poder realitzar la selecció de les dades d'interès a analitzar, el primer pas és fer la lectura del fitxer CSV anomenat 'marketing_campaign.csv':

```{r message= FALSE, warning=FALSE}
data_clients<-read.csv("../data/marketing_campaign.csv", header=T, sep="\t")
```

D'aquestes 29 variables, ens interessa quedar-nos amb les següents:

- ID: identificador únic

  Perfil del client:
- Year_Birth
- Education
- Marital_status
- Income
- Kidhome
- Teenhome
- Dt_Customer

  Gasto per productes alimentaris:
- MntFruits
- MntMeatProducts
- MntFishProducts
- MntSweetProducts
- NumWebPurchases
- NumCatalogPurchases
- NumStorePurchases

La resta de variables, degut a que no es faran servir, s'eliminen del conjunt de dades:

```{r message= FALSE, warning=FALSE}
data_clients <- data_clients[, c('ID', 'Year_Birth', 'Education', 'Marital_Status', 'Income', 'Kidhome', 'Teenhome', 
                                 'Dt_Customer', 'MntFruits', 'MntMeatProducts', 'MntFishProducts', 'MntSweetProducts',
                                 'NumWebPurchases', 'NumCatalogPurchases', 'NumStorePurchases')]

```

*****
# Neteja de dades
*****

Abans de començar amb la neteja de dades, cal mirar el tipus de dades que R ha assignat a cada columna, i també amb la funció 'summary' es pot veure els valors màxims, mínims i les mitjanes de les variables numèriques.

```{r message= FALSE, warning=FALSE}
summary(data_clients)
```

Es pot observar que les variables 'Education', 'Marital Status' i 'Dt Customer' són les úniques expressades com a text. La resta de variables són numèriques.

Primer, es validarà que les variables de text 'Education' i 'Marital Status' es poden categoritzar:

```{r message= FALSE, warning=FALSE}
table(data_clients$Education)
table(data_clients$Marital_Status)
```

Totes dues variables es poden categoritzar:

```{r message= FALSE, warning=FALSE}
data_clients$Education <- as.factor(data_clients$Education)
data_clients$Marital_Status <- as.factor(data_clients$Marital_Status)
```


*****
## Zeros o elements buits
*****

### Les dades contenen zeros o elements buits? Com gestionaries aquests casos?

Les variables numèriques utilitzen el valor 0 per indicar que no es té informació. I les de tipus text ho indiquen mitjançant els elements buits.
El primer pas per a fer aquesta comprobació, es validar si existeixen valors buits en les variables seleccionades:

```{r message= FALSE, warning=FALSE}
colSums(is.na(data_clients))
```

En aquest cas, la variable 'Income' en té 24. Per tal de gestionar aquests valors, hi ha diverses tècniques que es poden aplicar:
- Eliminar aquests registres.
- Aplicar la mitjana dels valors més propers.

Degut a que es tracta d'1% dels registres totals, es preferible eliminar-los ja que l'impacte i la pèrduda de dades és mínima:

```{r message= FALSE, warning=FALSE}
data_clients <- na.omit(data_clients)
colSums(is.na(data_keep))
```


### Identificació i tractament de valors extrems

El següent pas és identificar els valors extrems, que són les dades que es troben allunyades de la distribució normal.

Utilitzarem la funció boxplots.stats() de R per anar revisant variable a variable si trobem registres amb valors extrems 
que es puguin considerar incorrectes o que ens pugui implicar una desviació important. 

VARIABLE YEAR_BIRTH

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$Year_Birth)$out
summary(data_clients$Year_Birth)

## En aquest cas considerem que aquests 3 valors són incorrectes, ja que implicaria que actualment tenen més de 130 anys.
## Decidim canviar-los per el valor mitjà.
median_year_birth <- data_clients$Year_Birth

data_clients$Year_Birth[(data_clients$Year_Birth==1893)] <- median_year_birth
data_clients$Year_Birth[(data_clients$Year_Birth==1900)] <- median_year_birth
data_clients$Year_Birth[(data_clients$Year_Birth==1899)] <- median_year_birth
```

VARIABLES EDUCATION, MARITAL STATUS, KIDHOME, TEENHOME I NUMSTORESPURCHASES:  

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$Education)$out
boxplot.stats(data_clients$Marital_Status)$out
boxplot.stats(data_clients$Kidhome)$out
boxplot.stats(data_clients$Teenhome)$out
boxplot.stats(data_clients$NumStorePurchases)$out

table(data_clients$Education)
table(data_clients$Marital_Status)
table(data_clients$Kidhome)
table(data_clients$Teenhome)
table(data_clients$NumStorePurchases)

## No sembla que hi hagin valors extrems. 
## Revisem els seus valor amb la funció table
```

VARIABLE DT_CUSTOMER:  
```{r message= FALSE, warning=FALSE}
# Revisem els anys de les dates de clients per si veiem alguna cosa rara.

boxplot(as.numeric(substring(data_clients$Dt_Customer,7,10)))
table(as.numeric(substring(data_clients$Dt_Customer,7,10)))

## Tant la seva representació en boxplot com en taula és correcta.
```
VARIABLE NUMWEBPURCHASES: 

```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$NumWebPurchases)$out
summary(data_clients$NumWebPurchases)

## Els valors extrems són valors que es poden donar. Els donem per bons.
```

VARIBALE NUMCATALOGPURCHAES:
```{r message= FALSE, warning=FALSE}
boxplot.stats(data_clients$NumCatalogPurchases)$out
summary(data_clients$NumCatalogPurchases)

## Els valors extrems són valors que es poden donar. Els donem per bons.
```
VARIABLE MNTFRUITS:
```{r message= FALSE, warning=FALSE}
## Al tenir tants valors diferents, representem el seu boxplot:

boxplot(data_clients$MntFruits)
summary(data_clients$MntFruits)

## Veiem que hi han valors que estàn fora de ho esperat pero no allunyats entre ells i a més es poden donar.
## Ho donem per bo.
```
VARIABLE MNTFISHPRODUCTS:
```{r message= FALSE, warning=FALSE}
 
## Al tenir tants valors diferents, representem el seu boxplot
boxplot(data_clients$MntFishProducts)
summary(data_clients$MntFishProducts)
## Veiem que hi han valors que estàn fora de ho esperat pero no allunyats entre ells i a més es poden donar.
## Ho donem per bo.
```
VARIABLE MNTSWEETPRODUCTS:
```{r message= FALSE, warning=FALSE}
boxplot(data_clients$MntSweetProducts)
summary(data_clients$MntSweetProducts)

## Veiem que hi han un valor que estàn molt fora de ho esperat.
## Al ser només un el canviem per la mitjana.

data_clients$MntSweetProducts[(data_clients$MntSweetProducts==262)] <- median(data_clients$MntSweetProducts)
```
VARIABLE MNTMEATPRODUCTS;
```{r message= FALSE, warning=FALSE}
## Camp MntMeatProducts:  
## Al tenir tants valors diferents, representem el seu boxplot
boxplot(data_clients$MntMeatProducts)
summary(data_clients$MntMeatProducts)
## Sembla que hi han uns 4 valors superiors dels 1500 i diferenciats dels altres.
table(data_clients$MntMeatProducts[(data_clients$MntMeatProducts>1500)] )
## Els canviem per la seva mitjana:
data_clients$MntMeatProducts[(data_clients$MntMeatProducts>1500)] <- median(data_clients$MntMeatProducts)
```



*****
## Anàlisi de les dades
*****

### Selecció dels grups de dades que es volen analitzar/comparar (planificació dels anàlisis a aplicar)

La selecció dels grups de dades ha de permetre realitzar les proves estadístiques en funció dels grups a comparar o analitzar.

Per això, es seleccionaran les dades en funció de les variables 'Education' i 'Marital Status', aquestes són les que s'han categoritzat anteriorment.

```{r message= FALSE, warning=FALSE}
#Agrupació per estudis:

data_clients.basic <- data_clients[data_clients$Education == "Basic",]
data_clients.graduation <- data_clients[data_clients$Education == "Graduation",]
data_clients.cycle <- data_clients[data_clients$Education == "2n Cycle",]
data_clients.master <- data_clients[data_clients$Education == "Master",]
data_clients.phd <- data_clients[data_clients$Education == "PhD",]

#Agrupació per estat civil:
data_clients.divorced <- data_clients[data_clients$Education == "Divorced",]
data_clients.married <- data_clients[data_clients$Education == "Married",]
data_clients.single <- data_clients[data_clients$Education == "Single" || data_clients$Education == "Alone",]
data_clients.together <- data_clients[data_clients$Education == "Together",]
data_clients.widow <- data_clients[data_clients$Education == "Widow",]

```


### Comprovació de la normalitat i homogeneïtat de la variància

Per a poder realitzar les proves estadístiques, cal comprovar la normalitat i la homogeneïtat de la variància.

En aquest cas utilitzarem el test de Shaprio-Wilk, on diu que si el p-valor és més petit que α=0,05, es conclou que les dades no estan seguint una distribució normal. Per contra, si p-valor es major que α=0,05, les dades sí que estan seguint una distribució normal.

Les variables que es mesurarà la normalitat són les del tipus numèric, i que no siguin la variable ID (corresponen a l'identificador), i Kidhome i Teenhome ja que corresponen a valors booleans del tipus 0 i 1.

```{r message= FALSE, warning=FALSE}
options(scipen = 100)
par(mfrow=c(2,2))

p_value <- 0.05

columnes <- colnames(data_clients)

colnames_not_check <- c("ID", "Kidhome", "Teenhome")

for (i in 1:ncol(data_clients)) {
  col <- data_clients[,i]
  if(is.numeric(col) && !is.element(colnames(data_clients)[i], colnames_not_check)){
    qqnorm(col, main = paste("Normal Q-Q plot: ", colnames(data_clients)[i]));
    qqline(col, col = 2)
    
    normality_pvalue <- shapiro.test(col)$p.value
    
    if(normality_pvalue < p_value){
      cat("Distribució NO normalitzada de la columna: ", colnames(data_clients)[i])
    }else{
      cat("Distribució normal de la columna: ", colnames(data_clients)[i])
    }
    cat("\n")
  }
}

```

Es pot observar en el diagrama Q-Q i fent el test Shapiro-Wilk, que cap de les variables està normalitzada.

Es proposa normalitzar les variables següents, ja que la resta, es bo que es vegin els valors reals: MntFruits, MntMeatProducts, MntFishProducts, MntSweetProducts, NumWebPurchases, NumCatalogPurchases, NumStorePurchases:

```{r message= FALSE, warning=FALSE}
if (!require('ggplot2')) install.packages('ggplot2'); library('ggplot2')

par(mfrow=c(2,2))

data_clients_normalitzat <- data_clients
data_clients_normalitzat$MntFruits <- log(data_clients_normalitzat$MntFruits)
data_clients_normalitzat$MntMeatProducts <- log(data_clients_normalitzat$MntMeatProducts)
data_clients_normalitzat$MntFishProducts <- log(data_clients_normalitzat$MntFishProducts)
data_clients_normalitzat$MntSweetProducts <- log(data_clients_normalitzat$MntSweetProducts)
data_clients_normalitzat$NumWebPurchases <- log(data_clients_normalitzat$NumWebPurchases)
data_clients_normalitzat$NumCatalogPurchases <- log(data_clients_normalitzat$NumCatalogPurchases)
data_clients_normalitzat$NumStorePurchases <- log(data_clients_normalitzat$NumStorePurchases)

ggplot(data_clients_normalitzat, aes(x = MntFruits)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntFruits")

ggplot(data_clients_normalitzat, aes(x = MntMeatProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntMeatProducts")

ggplot(data_clients_normalitzat, aes(x = MntFishProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntFishProducts")

ggplot(data_clients_normalitzat, aes(x = MntSweetProducts)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("MntSweetProducts")

ggplot(data_clients_normalitzat, aes(x = NumWebPurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumWebPurchases")

ggplot(data_clients_normalitzat, aes(x = NumCatalogPurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumCatalogPurchases")

ggplot(data_clients_normalitzat, aes(x = NumStorePurchases)) +
  geom_histogram() +
  ylab("Nombre total") +
  xlab("NumStorePurchases")

```

Un cop es tenen les dades normalitzades, es fa l'estudi de l'homoscedasticitat. S'utilitzarà el test de Fligner-Killeen ja que es volen comparar les dades normalitzades amb les que no ho han estat.

Tal i com passava amb el test Shapiro-Wilk, si el p-value és inferior a 0.05, es conclou que les dades no són homogènies:

```{r message= FALSE, warning=FALSE}

fligner.test(Year_Birth ~ MntFruits, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntMeatProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntFishProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ MntSweetProducts, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumWebPurchases, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumCatalogPurchases, data = data_clients_normalitzat)
fligner.test(Year_Birth ~ NumStorePurchases, data = data_clients_normalitzat)

```

Les variables següents són homogències ja que el p-value és superior a 0.05: Year_Birth by MntFishProducts, Year_Birth by NumWebPurchases.
La resta no ho són.


## Aplicació de proves estadístiques per comparar els grups de dades


